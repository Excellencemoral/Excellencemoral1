{"version":3,"file":"animate.js","sources":["src/animate.ts"],"sourcesContent":["import {LitElement, ReactiveControllerHost} from 'lit';\nimport {nothing, AttributePart} from 'lit/html.js';\nimport {directive, PartInfo, PartType} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\nimport {animateControllers} from './animate-controller.js';\nexport {AnimateController} from './animate-controller.js';\n\nexport type CSSValues = {\n  [index: string]: string | number;\n};\n\nexport type CSSPropertiesList = string[];\n\n// zIndex for \"in\" animations\nlet z = 0;\n\nconst disconnectedProps: Map<unknown, CSSValues> = new Map();\nconst renderedHosts: WeakSet<ReactiveControllerHost> = new WeakSet();\n\nexport type AnimateOptions = {\n  // Options used for the animation\n  animationOptions?: KeyframeAnimationOptions;\n  // List of css properties to animate\n  properties?: CSSPropertiesList;\n  // if `true`, the `animate` is disabled\n  disabled?: boolean;\n  // Callback run to produce a value which is dirty checked to determine if animation should run.\n  guard?: () => unknown;\n  // Id for this `animate`; used to link to other `animate`s via e.g. `inId`\n  id?: unknown;\n  // Set to the `animate` id to map to when rendering \"in\"\n  inId?: unknown;\n  // Keyframes to use when animating \"in\"\n  in?: Keyframe[];\n  // Keyframes to use when animating \"out\"\n  out?: Keyframe[];\n  // Set to true to match DOM position when animating \"out\"\n  stabilizeOut?: boolean;\n  // Skips animation when initially rendering\n  skipInitial?: boolean;\n  // Callback run when the `animate` animation starts\n  onStart?: (animate: Animate) => void;\n  // Callback run when the animation is complete\n  onComplete?: (animate: Animate) => void;\n  // Callback run to modify frames used to animate\n  onFrames?: (animate: Animate) => Keyframe[] | undefined;\n};\n\nexport const animationFrame = () =>\n  new Promise((resolve) => requestAnimationFrame(resolve));\n\n// Presets for animating \"in\" and \"out\" of the DOM.\nexport const flyBelow = [{transform: 'translateY(100%) scale(0)', opacity: 0}];\nexport const flyAbove = [{transform: 'translateY(-100%) scale(0)', opacity: 0}];\nexport const flyLeft = [{transform: 'translateX(-100%) scale(0)', opacity: 0}];\nexport const flyRight = [{transform: 'translateX(100%) scale(0)', opacity: 0}];\nexport const none = [{}];\nexport const fadeOut = [{opacity: 0}];\nexport const fade = fadeOut;\nexport const fadeIn = [{opacity: 0}, {opacity: 1}];\nexport const fadeInSlow = [\n  {opacity: 0},\n  {opacity: 0.25, offset: 0.75},\n  {opacity: 1},\n];\n\nconst diffOp = (a: number, b: number) => {\n  const v = a - b;\n  return v === 0 ? undefined : v;\n};\nconst quotientOp = (a: number, b: number) => {\n  const v = a / b;\n  return v === 1 ? undefined : v;\n};\n\n// Computes a transform given a before and after input for given properties.\nexport const transformProps = {\n  left: (a: number, b: number) => {\n    const value = diffOp(a, b);\n    return {value, transform: value && `translateX(${value}px)`};\n  },\n  top: (a: number, b: number) => {\n    const value = diffOp(a, b);\n    return {value, transform: value && `translateY(${value}px)`};\n  },\n  width: (a: number, b: number) => {\n    const value = quotientOp(a, b);\n    return {value, transform: value && `scaleX(${value})`};\n  },\n  height: (a: number, b: number) => {\n    const value = quotientOp(a, b);\n    return {value, transform: value && `scaleY(${value})`};\n  },\n};\n\nexport const defaultAnimationOptions: KeyframeAnimationOptions = {\n  duration: 333,\n  easing: `ease-in-out`,\n};\n\nexport const defaultCssProperties: CSSPropertiesList = [\n  'left',\n  'top',\n  'width',\n  'height',\n  'opacity',\n  'color',\n  'background',\n];\n\n// Dirty checks the value received from the `guard` option.\nconst isDirty = (value: unknown, previous: unknown) => {\n  if (Array.isArray(value)) {\n    // Dirty-check arrays by item\n    if (\n      Array.isArray(previous) &&\n      previous.length === value.length &&\n      value.every((v, i) => v === (previous as Array<unknown>)[i])\n    ) {\n      return false;\n    }\n  } else if (previous === value) {\n    // Dirty-check non-arrays by identity\n    return false;\n  }\n  return true;\n};\n\n// Mapping of node on which the `animate` directive is used to the `animate` directive.\n// Used to get the ancestor `animate` animations (which are used to modify\n// `animate` transforms), done by ascending the DOM.\nconst animateMap: WeakMap<Node, Animate> = new WeakMap();\n\n/**\n * `animate` directive class. Animates a node's position between renders.\n */\nexport class Animate extends AsyncDirective {\n  private _host?: LitElement;\n  private _fromValues?: CSSValues;\n  private _parentNode: Element | null = null;\n  private _nextSibling: Node | null = null;\n  private _shouldAnimate = true;\n  private _previousValue: unknown;\n  private _animateStyles?: string | undefined | null;\n  element!: HTMLElement;\n\n  shouldLog = false;\n  animateProps?: CSSValues;\n  frames?: Keyframe[];\n  animation?: Animation;\n  options!: AnimateOptions;\n  optionsOrCallback?: (() => AnimateOptions) | AnimateOptions;\n\n  finished!: Promise<void>;\n  private _resolveFinished?: () => void;\n\n  constructor(part: PartInfo) {\n    super(part);\n    if (part.type === PartType.CHILD) {\n      throw new Error(\n        'The `animate` directive must be used in attribute position.'\n      );\n    }\n    this.createFinished();\n  }\n\n  createFinished() {\n    this.resolveFinished?.();\n    this.finished = new Promise((r) => {\n      this._resolveFinished = r;\n    });\n  }\n\n  async resolveFinished() {\n    this._resolveFinished?.();\n    this._resolveFinished = undefined;\n  }\n\n  render(_options?: (() => AnimateOptions) | AnimateOptions) {\n    return nothing;\n  }\n\n  getController() {\n    return animateControllers.get(this._host!);\n  }\n\n  isDisabled() {\n    return this.options.disabled || this.getController()?.disabled;\n  }\n\n  override update(part: AttributePart, [options]: Parameters<this['render']>) {\n    const firstUpdate = this._host === undefined;\n    if (firstUpdate) {\n      this._host = part.options?.host as LitElement;\n      this._host.addController(this);\n      this.element = part.element;\n      animateMap.set(this.element, this);\n    }\n    this.optionsOrCallback = options;\n    if (firstUpdate || typeof options !== 'function') {\n      this._setOptions(options as AnimateOptions);\n    }\n    return this.render(options);\n  }\n\n  // TODO(sorvell): instead of a function/object, just use an object that the\n  // user can mutate and create accessors for the data that do lookups as needed.\n  // We're doing this every hostUpdate anyway and these lookups are fast.\n  private _setOptions(options?: AnimateOptions) {\n    options = options ?? {};\n    // Mixin controller options.\n    const animateController = this.getController();\n    if (animateController !== undefined) {\n      options = {\n        ...animateController.animateOptions,\n        ...options,\n      };\n      options.animationOptions = {\n        ...animateController.animateOptions.animationOptions,\n        ...options.animationOptions,\n      };\n    }\n    // Ensure there are some properties to animation and some animation options.\n    options!.properties ??= defaultCssProperties;\n    this.options = options;\n  }\n\n  // Measures and returns metrics for the element's bounding box and styling\n  private _measure() {\n    const props: CSSValues = {};\n    const bounds = this.element.getBoundingClientRect();\n    const computedStyle = getComputedStyle(this.element);\n    this.options.properties!.forEach((p) => {\n      const v =\n        bounds[p as keyof typeof bounds] ??\n        (!transformProps[p as keyof typeof transformProps]\n          ? computedStyle[p as keyof CSSStyleDeclaration]\n          : undefined);\n      const asNum = Number(v);\n      props[p] = isNaN(asNum) ? String(v) : asNum;\n    });\n    return props;\n  }\n\n  // Returns true if a `animate` should be started.\n  private _canStartAnimate() {\n    let dirty = true,\n      value = undefined;\n    if (this.options.guard) {\n      value = this.options.guard();\n      dirty = isDirty(value, this._previousValue);\n    }\n    this._shouldAnimate =\n      this._host!.hasUpdated &&\n      !this.isDisabled() &&\n      !this.isAnimating() &&\n      dirty &&\n      this.element.isConnected;\n    if (this._shouldAnimate) {\n      // Copy the value if it's an array so that if it's mutated we don't forget\n      // what the previous values were.\n      this._previousValue = Array.isArray(value) ? Array.from(value) : value;\n    }\n    return this._shouldAnimate;\n  }\n\n  hostUpdate() {\n    // TODO(sorvell): If options will change that will affect measuring,\n    // then the user must pass a callback which can be called at update time.\n    if (typeof this.optionsOrCallback === 'function') {\n      this._setOptions(this.optionsOrCallback());\n    }\n    if (this._canStartAnimate()) {\n      this._fromValues = this._measure();\n      // Record parent and nextSibling used to re-attach node when animating \"out\"\n      this._parentNode =\n        this._parentNode ?? (this.element.parentNode as Element);\n      this._nextSibling = this.element.nextSibling;\n    }\n  }\n\n  hostUpdated() {\n    this.apply();\n  }\n\n  override reconnected() {}\n\n  override disconnected() {\n    this.animateDisconnect();\n  }\n\n  resetStyles() {\n    if (this._animateStyles !== undefined) {\n      this.element.setAttribute('style', this._animateStyles ?? '');\n      this._animateStyles = undefined;\n    }\n  }\n\n  commitStyles() {\n    this._animateStyles = this.element.getAttribute('style');\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.animation as any)?.commitStyles();\n    this.animation?.cancel();\n  }\n\n  async apply() {\n    if (\n      !this._shouldAnimate ||\n      !this.element.isConnected ||\n      (this.options.skipInitial && !this.isHostRendered)\n    ) {\n      return;\n    }\n    this.beforeBeginAnimate();\n    // Wait for rendering so any sub-elements have a chance to render.\n    await animationFrame;\n    let frames: Keyframe[] | undefined;\n    const ancestors = this._getAncestors();\n    // These inherit from ancestors. This allows easier synchronization of\n    // child `animate`s within ancestor `animate`s.\n    const animationOptions = this._calcAnimationOptions(\n      this.options.animationOptions,\n      ancestors\n    );\n    const toValues = this._measure();\n    // Normal or inverse scale\n    if (this._fromValues !== undefined) {\n      const {from, to} = this._applyAncestorAdjustments(\n        this._fromValues,\n        toValues,\n        ancestors\n      );\n      this.log('measured', [this._fromValues, toValues, from, to]);\n      frames = this.calculateFrames(from, to);\n      // \"In\" `animate`.\n    } else {\n      const disconnected = disconnectedProps.get(this.options.inId);\n      if (disconnected) {\n        // use disconnected data only once.\n        disconnectedProps.delete(this.options.inId);\n        const {from, to} = this._applyAncestorAdjustments(\n          disconnected!,\n          toValues,\n          ancestors\n        );\n        frames = this.calculateFrames(from, to);\n        // \"merge\" with \"in\" frames\n        frames = this.options.in\n          ? [\n              {...this.options.in[0], ...frames![0]},\n              ...this.options.in.slice(1),\n              frames![1],\n            ]\n          : frames;\n        // adjust z so always on top...\n        z++;\n        frames!.forEach((f) => (f.zIndex = z));\n      } else if (this.options.in) {\n        frames = [...this.options.in, {}];\n      }\n    }\n    this.beginAnimate();\n    const animated = await this.animate(frames, animationOptions);\n    this.completeAnimate(animated);\n  }\n\n  // Experimental animate out functionality.\n  async animateDisconnect() {\n    if (!this._shouldAnimate) {\n      return;\n    }\n    if (this.options.id !== undefined) {\n      disconnectedProps.set(this.options.id, this._fromValues!);\n    }\n    if (this.options.out === undefined) {\n      return;\n    }\n    this.beforeBeginAnimate();\n    await animationFrame();\n    if (this._parentNode?.isConnected) {\n      // put element back in DOM\n      const ref =\n        this._nextSibling && this._nextSibling.parentNode === this._parentNode\n          ? this._nextSibling\n          : null;\n      this._parentNode.insertBefore(this.element, ref);\n      // Optionally move element back to its position before it was detached.\n      if (this.options.stabilizeOut) {\n        // Measure current position after re-attaching.\n        const shifted = this._measure();\n        this.log('stabilizing out');\n        // TODO(sorvell): these nudges could conflict with existing styling\n        // or animation but setting left/top should be rare, especially via\n        // animation.\n        const left =\n          (this._fromValues!.left as number) - (shifted.left as number);\n        const top = (this._fromValues!.top as number) - (shifted.top as number);\n        const isStatic = getComputedStyle(this.element).position === 'static';\n        if (isStatic && (left !== 0 || top !== 0)) {\n          this.element.style.position = 'relative';\n        }\n        if (left !== 0) {\n          this.element.style.left = left + 'px';\n        }\n        if (top !== 0) {\n          this.element.style.top = top + 'px';\n        }\n      }\n    }\n    // These inherit from ancestors. This allows easier synchronization of\n    // child `animate`s within ancestor `animate`s.\n    const animationOptions = this._calcAnimationOptions(\n      this.options.animationOptions\n    );\n    this.beginAnimate();\n    const animated = await this.animate(this.options.out, animationOptions);\n    this.completeAnimate(animated);\n    this.element.remove();\n  }\n\n  beforeBeginAnimate() {\n    this.createFinished();\n  }\n\n  beginAnimate() {\n    this.options.onStart?.(this);\n  }\n\n  completeAnimate(didAnimate: boolean) {\n    if (didAnimate) {\n      this.options.onComplete?.(this);\n    }\n    this._fromValues = undefined;\n    this.animateProps = undefined;\n    this.frames = undefined;\n    this.resolveFinished();\n  }\n\n  private _getAncestors() {\n    const ancestors = [];\n    for (\n      let p: Node | null | undefined = this.element.parentNode;\n      p;\n      p = p?.parentNode\n    ) {\n      const a = animateMap.get(p!);\n      if (a && !a.isDisabled() && a) {\n        ancestors.push(a);\n      }\n    }\n    return ancestors;\n  }\n\n  protected get isHostRendered() {\n    const hostRendered = renderedHosts.has(this._host!);\n    if (!hostRendered) {\n      this._host!.updateComplete.then(() => {\n        renderedHosts.add(this._host!);\n      });\n    }\n    return hostRendered;\n  }\n\n  private _calcAnimationOptions(\n    options: KeyframeAnimationOptions | undefined,\n    ancestors: Animate[] = this._getAncestors()\n  ) {\n    // merges this `animate`'s options over ancestor options over defaults\n    const animationOptions = {...defaultAnimationOptions};\n    ancestors.forEach((a) =>\n      Object.assign(animationOptions, a.options.animationOptions)\n    );\n    Object.assign(animationOptions, options);\n    return animationOptions;\n  }\n\n  // Adjust position based on ancestor scaling.\n  private _applyAncestorAdjustments(\n    from: CSSValues,\n    to: CSSValues,\n    ancestors: Animate[]\n  ) {\n    from = {...from};\n    to = {...to};\n    const ancestorProps = ancestors\n      .map((a) => a.animateProps)\n      .filter((a) => a !== undefined) as CSSValues[];\n    let dScaleX = 1;\n    let dScaleY = 1;\n    if (ancestorProps !== undefined) {\n      // gather scaling data for ancestors\n      ancestorProps.forEach((a) => {\n        if (a.width) {\n          dScaleX = dScaleX / (a.width as number);\n        }\n        if (a.height) {\n          dScaleY = dScaleY / (a.height as number);\n        }\n      });\n      // Move position by ancestor scaling amount.\n      if (from.left !== undefined && to.left !== undefined) {\n        from.left = dScaleX * (from.left as number);\n        to.left = dScaleX * (to.left as number);\n      }\n      if (from.top !== undefined && to.top !== undefined) {\n        from.top = dScaleY * (from.top as number);\n        to.top = dScaleY * (to.top as number);\n      }\n    }\n    return {from, to};\n  }\n\n  protected calculateFrames(from: CSSValues, to: CSSValues, center = false) {\n    const fromFrame: Keyframe = {};\n    const toFrame: Keyframe = {};\n    let hasFrames = false;\n    const props: CSSValues = {};\n    for (const p in to) {\n      const f = from[p],\n        t = to[p];\n      if (p in transformProps) {\n        const tp = transformProps[p as keyof typeof transformProps];\n        if (f === undefined || t === undefined) {\n          continue;\n        }\n        const op = tp(f as number, t as number);\n        if (op.transform !== undefined) {\n          props[p] = op.value!;\n          hasFrames = true;\n          fromFrame.transform = `${fromFrame.transform ?? ''} ${op.transform}`;\n        }\n      } else if (f !== t && f !== undefined && t !== undefined) {\n        hasFrames = true;\n        fromFrame[p] = f;\n        toFrame[p] = t;\n      }\n    }\n    fromFrame.transformOrigin = toFrame.transformOrigin = center\n      ? 'center center'\n      : 'top left';\n    this.animateProps = props;\n    return hasFrames ? [fromFrame, toFrame] : undefined;\n  }\n\n  protected async animate(\n    frames: Keyframe[] | undefined,\n    options = this.options.animationOptions\n  ) {\n    this.frames = frames;\n    if (this.isAnimating() || this.isDisabled()) {\n      return false;\n    }\n    if (this.options.onFrames) {\n      this.frames = frames = this.options.onFrames(this);\n      this.log('modified frames', frames);\n    }\n    if (frames === undefined) {\n      return false;\n    }\n    this.log('animate', [frames, options]);\n    this.animation = this.element.animate(frames, options);\n    const controller = this.getController();\n    controller?.add(this);\n    try {\n      await this.animation.finished;\n    } catch (e) {\n      // cancelled.\n    }\n    controller?.remove(this);\n    return true;\n  }\n\n  protected isAnimating() {\n    return this.animation?.playState === 'running' || this.animation?.pending;\n  }\n\n  log(message: string, data?: unknown) {\n    if (this.shouldLog && !this.isDisabled()) {\n      console.log(message, this.options.id, data);\n    }\n  }\n}\n\n/**\n * The `animate` directive animates a node's layout between renders.\n * It will perform a \"tweening\" animation between the two states based on\n * the options given. In addition, elements can animate when they initially\n * render to DOM and when they are removed.\n *\n * Options include:\n * * animationOptions:  configure animation via standard KeyframeAnimationOptions\n * * properties: list of properties to animate, defaults to\n * ['left', 'top','width', 'height', 'opacity', 'color', 'background']\n * * disabled: disables animation\n * * guard: function producing values that must change for the `animate` to run\n * * in: keyframes to use when animating in\n * * out: keyframes to use when animating out\n * * skipInitial: skip animating in the first time\n * * id: used to link to other `animate`s via `inId`\n * * inId: id of the `animate` to render from when animating in\n * * onStart: run when the `animate` starts\n * * onComplete: run when the `animate` completes\n * * onFrames: run when the frames are produces, use to modify frames\n */\nexport const animate = directive(Animate);\n"],"names":["z","disconnectedProps","Map","renderedHosts","WeakSet","animationFrame","Promise","resolve","requestAnimationFrame","flyBelow","transform","opacity","flyAbove","flyLeft","flyRight","none","fadeOut","fade","fadeIn","fadeInSlow","offset","diffOp","a","b","v","undefined","quotientOp","transformProps","left","value","top","width","height","defaultAnimationOptions","duration","easing","defaultCssProperties","animateMap","WeakMap","Animate","AsyncDirective","constructor","part","super","this","type","PartType","CHILD","Error","createFinished","resolveFinished","finished","r","_resolveFinished","render","_options","nothing","getController","animateControllers","get","_host","isDisabled","options","disabled","update","firstUpdate","host","addController","element","set","optionsOrCallback","_setOptions","u","animateController","animateOptions","animationOptions","properties","props","bounds","getBoundingClientRect","computedStyle","getComputedStyle","forEach","p","asNum","Number","isNaN","String","m","dirty","guard","previous","Array","isArray","length","every","i","isDirty","_previousValue","_shouldAnimate","hasUpdated","isAnimating","isConnected","from","hostUpdate","_canStartAnimate","_fromValues","_measure","_parentNode","parentNode","_nextSibling","nextSibling","hostUpdated","apply","reconnected","disconnected","animateDisconnect","resetStyles","_animateStyles","setAttribute","commitStyles","getAttribute","animation","cancel","skipInitial","isHostRendered","frames","beforeBeginAnimate","ancestors","_getAncestors","_calcAnimationOptions","toValues","to","_applyAncestorAdjustments","log","calculateFrames","inId","delete","in","slice","f","zIndex","beginAnimate","animated","animate","completeAnimate","id","out","ref","insertBefore","stabilizeOut","shifted","position","style","remove","onStart","didAnimate","onComplete","animateProps","_","push","hostRendered","has","updateComplete","then","add","j","Object","assign","S","ancestorProps","map","filter","dScaleX","dScaleY","center","fromFrame","toFrame","hasFrames","t","tp","op","transformOrigin","onFrames","controller","e","playState","pending","message","data","shouldLog","console","directive"],"mappings":"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"}