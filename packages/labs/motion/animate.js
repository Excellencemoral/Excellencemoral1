import{nothing as t}from"lit/html.js";import{directive as i,PartType as s}from"lit/directive.js";import{AsyncDirective as e}from"lit/async-directive.js";import{animateControllers as o}from"./animate-controller.js";export{AnimateController}from"./animate-controller.js";let n=0;const h=new Map,r=new WeakSet,a=()=>new Promise((t=>requestAnimationFrame(t))),l=[{transform:"translateY(100%) scale(0)",opacity:0}],c=[{transform:"translateY(-100%) scale(0)",opacity:0}],d=[{transform:"translateX(-100%) scale(0)",opacity:0}],u=[{transform:"translateX(100%) scale(0)",opacity:0}],v=[{}],m=[{opacity:0}],f=m,p=[{opacity:0},{opacity:1}],y=[{opacity:0},{opacity:.25,offset:.75},{opacity:1}],g=(t,i)=>{const s=t-i;return 0===s?void 0:s},A=(t,i)=>{const s=t/i;return 1===s?void 0:s},w={left:(t,i)=>{const s=g(t,i);return{value:s,transform:s&&`translateX(${s}px)`}},top:(t,i)=>{const s=g(t,i);return{value:s,transform:s&&`translateY(${s}px)`}},width:(t,i)=>{const s=A(t,i);return{value:s,transform:s&&`scaleX(${s})`}},height:(t,i)=>{const s=A(t,i);return{value:s,transform:s&&`scaleY(${s})`}}},b={duration:333,easing:"ease-in-out"},j=["left","top","width","height","opacity","color","background"],x=new WeakMap;class S extends e{constructor(t){if(super(t),this.t=null,this.i=null,this.o=!0,this.shouldLog=!1,t.type===s.CHILD)throw Error("The `animate` directive must be used in attribute position.");this.createFinished()}createFinished(){var t;null===(t=this.resolveFinished)||void 0===t||t.call(this),this.finished=new Promise((t=>{this.h=t}))}async resolveFinished(){var t;null===(t=this.h)||void 0===t||t.call(this),this.h=void 0}render(i){return t}getController(){return o.get(this.l)}isDisabled(){var t;return this.options.disabled||(null===(t=this.getController())||void 0===t?void 0:t.disabled)}update(t,[i]){var s;const e=void 0===this.l;return e&&(this.l=null===(s=t.options)||void 0===s?void 0:s.host,this.l.addController(this),this.element=t.element,x.set(this.element,this)),this.optionsOrCallback=i,(e||"function"!=typeof i)&&this.u(i),this.render(i)}u(t){var i,s;t=null!=t?t:{};const e=this.getController();void 0!==e&&((t={...e.animateOptions,...t}).animationOptions={...e.animateOptions.animationOptions,...t.animationOptions}),null!==(i=(s=t).properties)&&void 0!==i||(s.properties=j),this.options=t}v(){const t={},i=this.element.getBoundingClientRect(),s=getComputedStyle(this.element);return this.options.properties.forEach((e=>{var o;const n=null!==(o=i[e])&&void 0!==o?o:w[e]?void 0:s[e],h=Number(n);t[e]=isNaN(h)?n+"":h})),t}m(){let t,i=!0;return this.options.guard&&(t=this.options.guard(),i=((t,i)=>{if(Array.isArray(t)){if(Array.isArray(i)&&i.length===t.length&&t.every(((t,s)=>t===i[s])))return!1}else if(i===t)return!1;return!0})(t,this.p)),this.o=this.l.hasUpdated&&!this.isDisabled()&&!this.isAnimating()&&i&&this.element.isConnected,this.o&&(this.p=Array.isArray(t)?Array.from(t):t),this.o}hostUpdate(){var t;"function"==typeof this.optionsOrCallback&&this.u(this.optionsOrCallback()),this.m()&&(this.g=this.v(),this.t=null!==(t=this.t)&&void 0!==t?t:this.element.parentNode,this.i=this.element.nextSibling)}hostUpdated(){this.apply()}reconnected(){}disconnected(){this.animateDisconnect()}resetStyles(){var t;void 0!==this.A&&(this.element.setAttribute("style",null!==(t=this.A)&&void 0!==t?t:""),this.A=void 0)}commitStyles(){var t,i;this.A=this.element.getAttribute("style"),null===(t=this.animation)||void 0===t||t.commitStyles(),null===(i=this.animation)||void 0===i||i.cancel()}async apply(){if(!this.o||!this.element.isConnected||this.options.skipInitial&&!this.isHostRendered)return;let t;this.beforeBeginAnimate(),await a;const i=this._(),s=this.j(this.options.animationOptions,i),e=this.v();if(void 0!==this.g){const{from:s,to:o}=this.S(this.g,e,i);this.log("measured",[this.g,e,s,o]),t=this.calculateFrames(s,o)}else{const s=h.get(this.options.inId);if(s){h.delete(this.options.inId);const{from:o,to:r}=this.S(s,e,i);t=this.calculateFrames(o,r),t=this.options.in?[{...this.options.in[0],...t[0]},...this.options.in.slice(1),t[1]]:t,n++,t.forEach((t=>t.zIndex=n))}else this.options.in&&(t=[...this.options.in,{}])}this.beginAnimate();const o=await this.animate(t,s);this.completeAnimate(o)}async animateDisconnect(){var t;if(!this.o)return;if(void 0!==this.options.id&&h.set(this.options.id,this.g),void 0===this.options.out)return;if(this.beforeBeginAnimate(),await a(),null===(t=this.t)||void 0===t?void 0:t.isConnected){const t=this.i&&this.i.parentNode===this.t?this.i:null;if(this.t.insertBefore(this.element,t),this.options.stabilizeOut){const t=this.v();this.log("stabilizing out");const i=this.g.left-t.left,s=this.g.top-t.top;!("static"===getComputedStyle(this.element).position)||0===i&&0===s||(this.element.style.position="relative"),0!==i&&(this.element.style.left=i+"px"),0!==s&&(this.element.style.top=s+"px")}}const i=this.j(this.options.animationOptions);this.beginAnimate();const s=await this.animate(this.options.out,i);this.completeAnimate(s),this.element.remove()}beforeBeginAnimate(){this.createFinished()}beginAnimate(){var t,i;null===(i=(t=this.options).onStart)||void 0===i||i.call(t,this)}completeAnimate(t){var i,s;t&&(null===(s=(i=this.options).onComplete)||void 0===s||s.call(i,this)),this.g=void 0,this.animateProps=void 0,this.frames=void 0,this.resolveFinished()}_(){const t=[];for(let i=this.element.parentNode;i;i=null==i?void 0:i.parentNode){const s=x.get(i);s&&!s.isDisabled()&&s&&t.push(s)}return t}get isHostRendered(){const t=r.has(this.l);return t||this.l.updateComplete.then((()=>{r.add(this.l)})),t}j(t,i=this._()){const s={...b};return i.forEach((t=>Object.assign(s,t.options.animationOptions))),Object.assign(s,t),s}S(t,i,s){t={...t},i={...i};const e=s.map((t=>t.animateProps)).filter((t=>void 0!==t));let o=1,n=1;return void 0!==e&&(e.forEach((t=>{t.width&&(o/=t.width),t.height&&(n/=t.height)})),void 0!==t.left&&void 0!==i.left&&(t.left=o*t.left,i.left=o*i.left),void 0!==t.top&&void 0!==i.top&&(t.top=n*t.top,i.top=n*i.top)),{from:t,to:i}}calculateFrames(t,i,s=!1){var e;const o={},n={};let h=!1;const r={};for(const s in i){const a=t[s],l=i[s];if(s in w){const t=w[s];if(void 0===a||void 0===l)continue;const i=t(a,l);void 0!==i.transform&&(r[s]=i.value,h=!0,o.transform=`${null!==(e=o.transform)&&void 0!==e?e:""} ${i.transform}`)}else a!==l&&void 0!==a&&void 0!==l&&(h=!0,o[s]=a,n[s]=l)}return o.transformOrigin=n.transformOrigin=s?"center center":"top left",this.animateProps=r,h?[o,n]:void 0}async animate(t,i=this.options.animationOptions){if(this.frames=t,this.isAnimating()||this.isDisabled())return!1;if(this.options.onFrames&&(this.frames=t=this.options.onFrames(this),this.log("modified frames",t)),void 0===t)return!1;this.log("animate",[t,i]),this.animation=this.element.animate(t,i);const s=this.getController();null==s||s.add(this);try{await this.animation.finished}catch(t){}return null==s||s.remove(this),!0}isAnimating(){var t,i;return"running"===(null===(t=this.animation)||void 0===t?void 0:t.playState)||(null===(i=this.animation)||void 0===i?void 0:i.pending)}log(t,i){this.shouldLog&&!this.isDisabled()&&console.log(t,this.options.id,i)}}const $=i(S);export{S as Animate,$ as animate,a as animationFrame,b as defaultAnimationOptions,j as defaultCssProperties,f as fade,p as fadeIn,y as fadeInSlow,m as fadeOut,c as flyAbove,l as flyBelow,d as flyLeft,u as flyRight,v as none,w as transformProps};
//# sourceMappingURL=animate.js.map
